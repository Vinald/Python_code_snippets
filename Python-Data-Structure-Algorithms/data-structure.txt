What is a data structure?
    
    A data structure is a way of organizing and storing data in a computer so that it can be accessed and modified efficiently. Data structures provide a means to manage large amounts of data effectively for various applications. They define the relationship between the data, the operations that can be performed on the data, and the constraints on these operations.

    Data structures can be broadly classified into two categories:

    1. Built-in Types of Data Structures
    2. User-defined Types of Data Structures

    Built-in Types of Data Structures

    1. Lists
       Description:
        Ordered collections that are mutable, meaning you can modify their contents. They allow duplicate elements.
       
       Use Case:
        Storing a sequence of items where order matters, such as a list of tasks or a collection of names.

    2. Tuples
       Description:
        Ordered collections that are immutable, meaning their contents cannot be changed after creation. They also allow duplicate elements.
       
       Use Case:
        Storing fixed collections of items, such as coordinates (latitude, longitude) or database records.

    3. Sets
       Description:
        Unordered collections of unique elements, meaning no duplicates are allowed.

       Use Case:
        Storing unique items, such as a collection of distinct values or removing duplicates from a list.

    4. Dictionaries
       Description:
        Unordered collections of key-value pairs. Each key must be unique, and keys are used to retrieve corresponding values.

       Use Case:
        Storing and quickly looking up values based on unique keys, such as a phone book or a dictionary of word definitions.

    User-defined Types of Data Structures

    1. Arrays
       Description:
        Collections of elements identified by index. They are typically of fixed size and contain elements of the same type.
       
       Use Case:
        Efficiently storing and accessing a collection of items, such as a list of numbers.

    2. Linked Lists
       Description:
        Linear collections of elements where each element points to the next. Elements are called nodes, and the first node is called the head.
       
       Use Case:
        Efficiently inserting and deleting elements, especially when the position is known, such as in a to-do list.

    3. Stacks
       Description:
        Collections of elements with Last In First Out (LIFO) order. The last element added is the first to be removed.
       
         

      Use Case:
      Managing function calls in programming, undo mechanisms in text editors, or tracking browser history.

   4. Queues
      Description:
      Collections of elements with First In First Out (FIFO) order. The first element added is the first to be removed.
      
      Use Case:
      Managing tasks in a print queue, handling requests in web servers, or breadth-first search in algorithms.

   5. Trees
      Description:
      Hierarchical data structures with a root node and children nodes. Each node may have zero or more children.
      
      Binary Trees: Each node has at most two children.

      Binary Search Trees (BSTs): Binary trees where left children are less than the parent and right children are greater.
      
      AVL Trees: Self-balancing BSTs where heights of subtrees differ by at most one.
         
      Red-Black Trees: Self-balancing BSTs with specific balancing rules to ensure logarithmic height.
      
      B-Trees: Self-balancing trees optimized for systems that read and write large blocks of data.
         
      B+ Trees: Variants of B-trees where all values are at leaf level, linked for efficient sequential access.
      
      Use Case:
      Efficient searching, inserting, and deleting operations, such as in databases and file systems.

   6. Graphs
      Description:
      Collections of nodes (vertices) connected by edges. Can represent various relationships between objects.
      
      Directed Graphs:
         Edges have a direction, indicating a one-way relationship.
      
      Undirected Graphs:
         Edges have no direction, indicating a two-way relationship.
      
      Weighted Graphs:
         Edges have weights representing the cost or distance between nodes.
      
      Unweighted Graphs:
         Edges do not have weights.

      Use Case:
      Representing networks like social networks, transportation networks, or dependency graphs in tasks.

   7. Hash Tables
      Description:
      Data structures that map keys to values for efficient lookup. They use a hash function to compute an index into an array of buckets or slots.
      
      Use Case:
      Fast data retrieval, such as in dictionaries, caches, and database indexing.

   8. Heaps
      Description:
      Specialized tree-based structures used to manage a priority queue. Elements are arranged such that the parent node is either greater than or equal to (max-heap) or less than or equal to (min-heap) its children.
      
      Use Case:
      Implementing priority queues, scheduling processes in operating systems, or finding the k-largest elements in a list.

   9. Disjoint Sets
      Description:
      Data structures used to manage a partition of a set into disjoint subsets. Supports efficient union and find operations.
      
      Use Case:
      Managing connected components in a graph, network connectivity, or Kruskal's algorithm for minimum spanning trees.
